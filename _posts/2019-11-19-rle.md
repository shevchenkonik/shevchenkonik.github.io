---
layout: post
title: "Run-length Encoding Algorithm in JavaScript"
comments: false
description: "The article is about run-length encoding algorithm in javascript for Image Compression"
keywords: "rle, run length encoding, binary endcoding"
---

## Abstract

Compression purpose to reduce the size of data and speed up the data transmission process between client and server. To solve the size problem of data and transmission process, we implement Run-length Encoding (rle) algorithm for JavaScript. This implementation currently works only for binary data (bi-level) and rle is better for this case based on the results of research.

## Introduction

Run-length Encoding is a form of lossless data compression in which a stream of data is given the array of numbers (i.e. `[0, 0, 0, 1, 1, 0, 0]`) and the output is a sequence of counts of consecutive data values in array (i.e. `[3, 0, 2, 1, 2, 0]`).

## Method

### Compression data:

1. Check of the current value with the neighbors values, when current value same with neighbors, then combine the values into one and add counter to the values.
2. Go to the next value and if the current value isn't the same with the neighbor's value then save the current value and repeat the first step back.
3. After processes 1 and 2 finished, then save compression result as an array.

```javascript
function encode(arr) {
  let encoding = [],
    previous,
    count;

  for (count = 1, previous = arr[0], i = 1; i < arr.length; i++) {
    if (arr[i] !== previous) {
      encoding.push(count, previous);
      count = 1;
      previous = arr[i];
    } else {
      count++;
    }
  }

  /**
   * Add a last pair
   */
  encoding.push(count, previous);

  return encoding;
}
```

### Decompression data:

1. Check the current value with the neighbor's value, neighbors value is the amount of current value.
2. Wrote the current value as much as the neighbor's value who has been checked.
3. Go to the next value and repeat the first step and second step until all back to the original values.

```javascript
function decode(encoded) {
  let uncompressed = [];

  /**
   * Create a new array with decoded data
   */
  encoded.map((element, ind) => {
    if (ind % 2 === 0) {
      uncompressed.push(...[...Array(element).fill(encoded[ind + 1])]);
    }
  });

  return uncompressed;
}
```

## Example of compression data

Input data:

```bash
[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]
```

Output data:

```bash
[7, 0, 3, 1, 5, 0]
```

We were able to compress the data from 15 elements down to 6. (60%)

## Implementation

I create a tiny (117 bytes) javascript library on github: [rle-data](https://github.com/shevchenkonik/rle-data)

If you want to use implementation, you can add lib to your project with npm:

```javascript
npm i --save-dev rle-data
```

## References

- [comparative analysis run-length encoding algorithm and Fibonacci code algorithm on image compression](https://www.researchgate.net/publication/334632557_Comparative_Analysis_Run-Length_Encoding_Algorithm_and_Fibonacci_Code_Algorithm_on_Image_Compression)

- [run-length encoding](https://en.wikipedia.org/wiki/Run-length_encoding)

- [rosettacode. rle](http://rosettacode.org/wiki/Run-length_encoding)

- [dunn, Christopher (1987). "smile! you're on RLE!"](http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf)
